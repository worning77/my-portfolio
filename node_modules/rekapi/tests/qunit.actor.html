<!DOCTYPE html>
<html>
<head>
  <link href="../bower_components/qunit/qunit/qunit.css" rel="stylesheet" type="text/css" />
  <script>
  var mockTime = function () {
        return +(new Date());
      };
  var SHIFTY_DEBUG_NOW = function () {
        return mockTime();
      };
  var global = window;
  </script>
  <script src="../bower_components/qunit/qunit/qunit.js"></script>
  <script src="../bower_components/lodash/dist/lodash.js"></script>
  <script src="../bower_components/shifty/dist/shifty.js"></script>
  <script src="../src/rekapi.core.js"></script>
  <script src="../src/rekapi.actor.js"></script>
  <script src="../src/rekapi.keyframe-property.js"></script>
  <script src="../src/rekapi.init.js"></script>
  <script>
  function setupTestRekapi () {
    return new Rekapi();
  }

  function  setupTestActor (forRekapi) {
    var actor = new Rekapi.Actor();
    forRekapi.addActor(actor);
    return actor;
  }

  (function runTests () {

    module('_updateState');

    test('Correctly interpolate Actor positions at various positions mid-frame',
        function () {
      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);


      testActor.keyframe(0, {
        'x': 0
        ,'y': 0
      }).keyframe(1000, {
        'x': 100
        ,'y':100
      });


      testActor._updateState(0);

      equal(testActor.get().x, 0,
        'Value "x" was properly interpolated at position 0.0');
      equal(testActor.get().y, 0,
        'Value "y" was properly interpolated at position 0.0');


      testActor._updateState(500);

      equal(testActor.get().x, 50,
        'Value "x" was properly interpolated at position 0.5');
      equal(testActor.get().y, 50,
        'Value "y" was properly interpolated at position 0.5');


      testActor._updateState(1000);

      equal(testActor.get().x, 100,
        'Value "x" was properly interpolated at position 1.0');
      equal(testActor.get().y, 100,
        'Value "y" was properly interpolated at position 1.0');
    });


    test('Early-ending keyframe tracks produce a useful value after they have ended',
        function () {

      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);

      testActor.keyframe(0,{
        'x': 100
      }).keyframe(1000, {
        'y': 200
      });

      testActor._updateState(500);
      equal(testActor.get().x, 100,
          'Value only has a start point, therefore a calculated midpoint is undefined.');
    });


    test('Interpolate Actor positions at various positions mid-frame',
        function () {

      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);


      testActor.keyframe(1000, {
          'x': 0
          ,'y':0
      }).keyframe(2000, {
        'x': 100
        ,'y':100
      });

      testActor._updateState(1000);

      equal(testActor.get().x, 0,
        'Value "x" was properly interpolated at position 0.0');
      equal(testActor.get().y, 0,
        'Value "y" was properly interpolated at position 0.0');


      testActor._updateState(1500);

      equal(testActor.get().x, 50,
        'Value "x" was properly interpolated at position 0.5');
      equal(testActor.get().y, 50,
        'Value "y" was properly interpolated at position 0.5');


      testActor._updateState(2000);

      equal(testActor.get().x, 100,
        'Value "x" was properly interpolated at position 1.0');
      equal(testActor.get().y, 100,
        'Value "y" was properly interpolated at position 1.0');
    });



    test('Applied easing is taken from the destination frame', function () {

      var testRekapi
          ,testActor
          ,tweenableComparator;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);

      testActor.keyframe(0, {
        'x': 0
      }, 'linear').keyframe(1000, {
        'x': 100
      }, 'easeInSine').keyframe(2000, {
        'x': 200
      }, 'easeOutCirc');

      tweenableComparator = Tweenable.interpolate({
        'x': 0
      }, {
        'x': 100
      }, .5, 'easeInSine');

      testActor._updateState(500);
      equal(testActor.get().x, tweenableComparator.x,
        'Value "x" was properly interpolated at position 0.5 with "easeInSine"');


      tweenableComparator = Tweenable.interpolate({
        'x': 100
      }, {
        'x': 200
      }, .5, 'easeOutCirc');

      testActor._updateState(1500);
      equal(testActor.get().x, tweenableComparator.x,
        'Value "x" was properly interpolated at position 0.5 with "easeOutCirc"');

    });


    test('If there are no current or future properties, use the latest property',
        function () {

      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);

      testActor.keyframe(0, {
        'x': 50
        ,'y': 50
      }).keyframe(1000, {
        'y': 100
      }).keyframe(2000, {
        'y': 150
      });

      testActor._updateState(500);

      equal(testActor.get().x, 50
        ,'Got the x value from one keyframe back');
      equal(testActor.get().y, 75
        ,'Got the corrext y midpoint');

      testActor._updateState(1500);

      equal(testActor.get().x, 50
        ,'Got the x value from two keyframes back');
    });


    test('If a given millisecond doesn\'t have a previous keyframe, return null',
        function () {

      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);

      testActor.keyframe(0, {
        'x': 50
      }).keyframe(1000, {
        'x': 100
        ,'y': 100
      });

      testActor._updateState(500);

      equal(testActor.get().x, 75
        ,'Got the most recent x value');
      equal(testActor.get().y, 100
        ,'Got the correct y midpoint');
    });


    test('Handles not-yet-reached keyframes appropriately (single track)',
      function () {

      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);

      testActor.keyframe(0,{
        // Nothing!
      }).keyframe(1000, {
        'x': 100
      });

      testActor._updateState(500);
      equal(testActor.get().x, 100,
          'Value only has an end point, therefore a calculated midpoint is undefined.');
    });


    test('Handles not-yet-reached keyframes appropriately (multiple tracks)', function () {
      var actor = new Rekapi.Actor();

      actor.keyframe(0, {
        x: 1
      }).keyframe(1000, {
        y: 10
      });

      actor._updateState(500);

      equal(actor.get().y, 10,
          'Keyframe 0 for Y was implicitly defined and tweened against');
    });

    test('Only updates actors when active',
      function () {

      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);

      testActor.keyframe(0,{
        'x': 0
      })
      .setActive(250, false)
      .setActive(750, true)
      .keyframe(1000, {
        'x': 100
      });

      testActor._updateState(100);
      var active100 = testActor.wasActive;
      var x100 = testActor.get().x;
      testActor._updateState(500);
      var active500 = testActor.wasActive;
      var x500 = testActor.get().x;
      testActor._updateState(900);
      var active900 = testActor.wasActive;
      var x900 = testActor.get().x;

      equal(active100, true, 'Actor was active at 100ms.');
      equal(x100, 10, 'x was updated at 100ms.');
      equal(active500, false, 'Actor was not active at 500ms.');
      equal(x500, 10, 'x was not updated at 500ms.');
      equal(active900, true, 'Actor was active at 900ms.');
      equal(x900, 90, 'x was updated at 900ms.');
    });


    module('addKeyframeProperty');


    test('Adding a KeyframeProperty creates a link between the property and the actor.',
        function () {
      var actor = new Rekapi.Actor();
      var keyframeProperty = new Rekapi.KeyframeProperty(0, 'x', 50);

      actor.addKeyframeProperty(keyframeProperty);

      equal(keyframeProperty.actor, actor
          ,'The KeyframeProperty has an internal reference to the Actor.');
      equal(actor._keyframeProperties[keyframeProperty.id], keyframeProperty
          ,'The Actor has an internal reference to the KeyframeProperty.');
    });


    module('beforeAddKeyframeProperty event');


    test('beforeAddKeyframeProperty reflects the state of the animation before the keyframe property is added', function () {
      var rekapi = setupTestRekapi();
      var actor = setupTestActor(rekapi);

      actor.keyframe(50, { x: 0 });
      var keyframeProperty = actor.getKeyframeProperty('x', 0);

      rekapi.on('beforeAddKeyframeProperty', function () {
        equal(rekapi.getAnimationLength(), 50, 'The timeline does not reflect the addition of the new keyframe');
      });

      actor.keyframe(100, { x: 10 });
    });


    module('removeKeyframe');


    test('Keyframes can be removed from the middle of the animation',
        function () {

      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);

      testActor
        .keyframe(0, { x: 1 })
        .keyframe(1000, { x: 2 })
        .keyframe(2000, { x: 3 });

      testActor.removeKeyframe(1000);

      equal(testActor._propertyTracks.x.length, 2,
          'A keyframe property was removed from testActor._propertyTracks.x');

      equal(_.keys(testActor._keyframeProperties).length, 2,
          'A keyframe property was deleted from the internal hash');
    });


    test('Single keyframe properties can be removed from an actor at a time',
        function () {

      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);

      testActor.keyframe(0, {
          'x': 0
        }).keyframe(1000, {
          'x': 50
        }).keyframe(2000, {
          'x': 100
        });

     testActor.removeKeyframe(1000);

     equal(testActor._propertyTracks.x.length, 2
          ,'x track was shortened properly');
     equal(testActor._propertyTracks.x[0].value, 0
          ,'First x property was unchanged');
     equal(testActor._propertyTracks.x[1].value, 100
          ,'Last x property was unchanged');
    });

    test('Multiple keyframe properties can be removed from an actor at a time',
        function () {

      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);

      testActor.keyframe(0, {
          'x': 0
          ,'y': 1
        }).keyframe(1000, {
          'x': 50
          ,'y': 51
        }).keyframe(2000, {
          'x': 100
          ,'y': 101
        });

     testActor.removeKeyframe(1000);

     equal(testActor._propertyTracks.x.length, 2
          ,'x track was shortened properly');
     equal(testActor._propertyTracks.y.length, 2
          ,'y track was shortened properly');
     equal(testActor._propertyTracks.x[0].value, 0
          ,'First x property was unchanged');
     equal(testActor._propertyTracks.x[1].value, 100
          ,'Last x property was unchanged');
     equal(testActor._propertyTracks.y[0].value, 1
          ,'First y property was unchanged');
     equal(testActor._propertyTracks.y[1].value, 101
          ,'Last y property was unchanged');
     equal(testActor._propertyTracks.x[0].nextProperty, testActor._propertyTracks.x[1]
          ,'First x property is linked to second');
     equal(testActor._propertyTracks.x[1].nextProperty, null
          ,'Second x property is linked to null');
    });

    test('Keyframes can be removed from the end of the animation',
        function () {

      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);

      testActor
        .keyframe(0, {
          'x': 1
        })
        .keyframe(1000, {
          'x': 2
        })
        .keyframe(2000, {
          'x': 3
        });

      testActor.removeKeyframe(2000);

      equal(testRekapi.getAnimationLength(), 1000,
          'The animation length is shortened when the final keyframe is removed');
      equal(testActor._propertyTracks.x.length, 2,
          'The property track is the correct length');
      equal(testActor._propertyTracks.x[0].nextProperty, testActor._propertyTracks.x[1],
          'First x property is linked to second');
      equal(testActor._propertyTracks.x[1].nextProperty, null,
          'Second x property is linked to null');
    });

    test('.removeAllKeyframes removes all keyframes', function () {
      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);

      testActor
        .keyframe(0, {
          'x': 0
        })
        .keyframe(1000, {
          'x': 1
        })
        .keyframe(2000, {
          'x': 2
        });

      testActor.removeAllKeyframes();

      equal(testRekapi.getAnimationLength(), 0, 'Animation length is 0');
      equal(testActor._propertyTracks.x, undefined, 'x property track no longer exists');
    });


    module('copyKeyframe');


    test('Unmodified keyframe properties are copied.', function () {
      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);
      testActor.keyframe(0, {
          'x': 50
        }, {
          'x': 'easeInQuad'
        });

      testActor.copyKeyframe(1000, 0);

      equal(testActor._propertyTracks.x.length, 2,
          'Now there are two properties');
      ok(testActor._propertyTracks.x[0] !== testActor._propertyTracks.x[1],
          'The two properties are not the same Object reference');
      equal(testActor._propertyTracks.x[0].value,
          testActor._propertyTracks.x[1].value,
          'Copied property value is the same as the source property value')
      equal(testActor._propertyTracks.x[0].easing,
          testActor._propertyTracks.x[1].easing,
          'Copied property easing is the same as the source property easing')
    });


    module('modifyKeyframe');


    test('Original keyframe position property is changed' , function () {
      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);

      testActor
        .keyframe(0, {
          'x': 100
        }).keyframe(1000, {
          'x': 200
        });

      testActor.modifyKeyframe(0, {
        'x': 0
      });

      testActor._updateState(500);
      equal(testActor.get().x, 100,
          'First keyframe was modified and factored into the position calculation');
    });


    test('Original keyframe easing property is changed' , function () {
      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);

      testActor
        .keyframe(0, {
          'x': 0
        }, {
          'x': 'elastic'
        }).keyframe(1000, {
          'x': 100
        }, {
          'x': 'elastic'
        });

      testActor.modifyKeyframe(1000, {}, {
        'x': 'linear'
      });

      testActor._updateState(500);
      equal(testActor.get().x, 50,
          'Second keyframe\'s easing  was modified and factored into the position calculation');
    });


    module('hasKeyframeAt');


    test('Actor can determine if it has a keyframe at a given millisecond' , function () {
      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);

      testActor
        .keyframe(0, {
          'x': 0
        }, {
          'x': 'elastic'
        }).keyframe(1000, {
          'x': 100
        }, {
          'x': 'elastic'
        });

      equal(testActor.hasKeyframeAt(500), false,
          'Keyframe does not exist at 500ms');
      equal(testActor.hasKeyframeAt(2000), false,
          'Keyframe does not exist at 2000ms');
      equal(testActor.hasKeyframeAt(1000), true,
          'Keyframe exists at 1000ms');
    });


    test('Actor can determine if it has a keyframe on a given property track' , function () {
      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);

      testActor
        .keyframe(0, {
          'x': 0
        }, {
          'x': 'elastic'
        }).keyframe(1000, {
          'x': 100
        }, {
          'x': 'elastic'
        });

      equal(testActor.hasKeyframeAt(0, 'y'), false,
          'Keyframe does not exist at 0ms on an unknown track');
      equal(testActor.hasKeyframeAt(1200, 'x'), false,
          'Keyframe does not exist at 1200ms on the x track');
      equal(testActor.hasKeyframeAt(1000, 'x'), true,
          'Keyframe exists at 1000ms on the x track');
    });

    test('Reordered property tracks', function () {
      var testRekapi = setupTestRekapi();
      var testActor = setupTestActor(testRekapi);

      testActor
        .keyframe(0,  { x: 0  })
        .keyframe(10, { x: 10 })
        .keyframe(20, { x: 20 });

      testActor.modifyKeyframeProperty('x', 10, { millisecond: 30 });
      equal(testActor.hasKeyframeAt(20, 'x'), true);
      equal(testActor.hasKeyframeAt(30, 'x'), true);
    });


    module('moveKeyframe');


    test('Does not move a keyframe to a point on the timeline when there already is one', function () {
      var testRekapi = setupTestRekapi();
      var testActor = setupTestActor(testRekapi);

      testActor
        .keyframe(0, {x: 1})
        .keyframe(10, {x: 2})
        .keyframe(20, {x: 3});

      var movedKeyframe = testActor.moveKeyframe(20, 10);
      var secondKeyframeX = testActor.getKeyframeProperty('x', 10);
      var thirdKeyframeX = testActor.getKeyframeProperty('x', 20);

      equal(movedKeyframe, false,
          'moveKeyframe indicated that keyframe was not moved');
      equal(secondKeyframeX.value, 2,
          'The keyframe already at the targeted time was not modified');
      equal(thirdKeyframeX.value, 3,
          'The keyframe requested to be moved was not modified.');
    });


    test('Does not move a keyframe if there is nothing at the requested point on the timeline', function () {
      var testRekapi = setupTestRekapi();
      var testActor = setupTestActor(testRekapi);

      testActor
        .keyframe(0, {x: 1})
        .keyframe(10, {x: 2});

      var movedKeyframe = testActor.moveKeyframe(20, 30);

      equal(movedKeyframe, false,
          'moveKeyframe indicated that keyframe was not moved');
    });


    test('Moves keyframe to requested point on the timeline', function () {
      var testRekapi = setupTestRekapi();
      var testActor = setupTestActor(testRekapi);

      testActor
        .keyframe(0, {x: 1})
        .keyframe(10, {x: 2});

      var movedKeyframe = testActor.moveKeyframe(10, 20);
      var hasKeyframeAtTarget = testActor.hasKeyframeAt(20);
      var hasKeyframeAtOldPosition = testActor.hasKeyframeAt(10);
      var animationLength = testRekapi.getAnimationLength();

      equal(movedKeyframe, true,
          'moveKeyframe indicated that keyframe was moved');
      equal(hasKeyframeAtTarget, true,
          'Keyframe exists at requested destination');
      equal(hasKeyframeAtOldPosition, false,
          'Keyframe does not exist at previous position on the timeline');
      equal(animationLength, 20,
          'Animation length was updated');
    });


    module('wait');


    test('Can copy keyframes (one initial keyframe)', function () {
      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);

      testActor.keyframe(0, {
        'x': 50
      }).wait(1000);


      equal(testActor._propertyTracks.x[1].value, 50,
          'The first keyframe was extended.');
    });


    test('Can copy keyframes (multiple initial keyframe)', function () {
      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);

      testActor.keyframe(0, {
        'x': 50
      }).keyframe(1000, {
        'x': 100
      }).wait(2000);


      equal(testActor._propertyTracks.x[2].value, 100,
          'The last keyframe was extended.');
    });


    test('wait() extends all lagging KeyframeProperties', function () {
      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);

      testActor.keyframe(0, {
        'x': 51
        ,'y': 50
      }).keyframe(1000, {
        'x': 101
        ,'y': 100
      });

      // Move the y property back a bit
      testActor.modifyKeyframeProperty('y', 1000, {
        'millisecond': 500
      });

      testActor.wait(2000);

      equal(testActor._propertyTracks.x[2].value, 101
          ,'x value is extended correctly');
      equal(testActor._propertyTracks.x[2].millisecond, 2000
          ,'x value is placed at 2000');
      equal(testActor._propertyTracks.x.length, 3
          ,'The x property track was extended');
      equal(testActor._propertyTracks.y.length, 4
          ,'The missing y property at millisecond 1000 was implicitly filled in and copied');
    });


    test('wait() copies all of the most recent KeyframeProperties',
        function () {

      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);

      testActor.keyframe(0, {
        'x': 0
        ,'y': 0
      }).keyframe(1000, {
        'x': 100
      }).wait(2000).keyframe(3000, {
        x: 200
        ,y: 200
      });

      equal(testActor._propertyTracks.y[1].millisecond, 1000
          ,'The missing Y property at the wait-start millisecond was explicitly filled in');
      equal(testActor._propertyTracks.y[0].value
          ,testActor._propertyTracks.y[1].value
          ,'The copied Y property has the same value as the initial Y property');
    });


    module('addActor');


    test('Can create keyframes on unattached actors', function () {
      var actor = new Rekapi.Actor();

      actor.keyframe(0, { x: 0 });
      ok(actor._propertyTracks.x, 'A property track was created');
    });


    test('Animation length is updated when an actor with prior keyframes is added.',
        function () {
      var actor = new Rekapi.Actor();

      actor
      .keyframe(0, { x: 0 })
      .keyframe(1000, { x: 10 });

      var rekapi = new Rekapi();
      rekapi.addActor(actor);

      equal(rekapi.getAnimationLength(), 1000,
        'Animation length reflects actor keyframes added before the Actor was added');
    });


    module('context');


    test('Actor inherits the Rekapi instance\'s context by default',
        function () {
      var testRekapi = new Rekapi();
      var testActor = setupTestActor(testRekapi);

      ok(testActor.context === testRekapi.context,
        'Actor has the same context as the Rekapi instance');
    });


    test('Actor can override the inherited context from the Rekapi instance',
        function () {
      var actorContext = {};
      var testRekapi = new Rekapi();
      var testActor = setupTestActor(testRekapi);

      testActor.context = actorContext;

      ok(testActor.context !== testRekapi.context,
        'Actor has a different context from the Rekapi instance');
      ok(testActor.context === actorContext,
        'Actor has retained the context that was explicitly set');
    });


    module('getKeyframeProperty');


    test('KeyframePropererties created with .keyframe can be retrieved with .getKeyframeProperty',
        function () {

      var testRekapi = setupTestRekapi();
      var testActor = setupTestActor(testRekapi);

      testActor.keyframe(0, { x: 10 });

      equal(testActor.getKeyframeProperty('x', 0).value, 10,
        'Retrieved the value of the KeyframeProperty that was set');
    });


    module('modifyKeyframeProperty');


    test('KeyframeProperties created with .keyframe can be modified with .modifyKeyframeProperty',
        function () {

      var testRekapi = setupTestRekapi();
      var testActor = setupTestActor(testRekapi);

      testActor.keyframe(0, { x: 10 });
      testActor.modifyKeyframeProperty('x', 0, { value: 20 });

      equal(testActor.getKeyframeProperty('x', 0).value, 20,
        'The KeyframeProperty was modified');
    });


    test('Moving a keyframe property over another one', function () {
      var testRekapi = setupTestRekapi();
      var testActor = setupTestActor(testRekapi);

      testActor
        .keyframe(0, { x: 1 })
        .keyframe(10, { x: 2 });

      throws(function () {
        testActor.modifyKeyframeProperty('x', 10, { millisecond: 0 });
      }, Error, 'Throws an error when moving a keyframe property over another');
    });


    test('Reordering properties', function () {
      var testRekapi = setupTestRekapi();
      var testActor = setupTestActor(testRekapi);

      testActor
        .keyframe(0, {x: 1})
        .keyframe(10, {x: 2});

      testActor.modifyKeyframeProperty('x', 0, { millisecond: 20 });
      var propertyAt10 = testActor.getKeyframeProperty('x', 10);
      var propertyAt20 = testActor.getKeyframeProperty('x', 20);

      equal(propertyAt10.nextProperty, propertyAt20,
        'First property is linked to second property');
      equal(propertyAt20.nextProperty, null,
        'Second property is linked to null');
    });


    module('removeKeyframeProperty');


    test('KeyframeProperties created with .keyframe can be removed with .removeKeyframeProperty',
        function () {

      var testRekapi = setupTestRekapi();
      var testActor = setupTestActor(testRekapi);

      testActor.keyframe(0, { x: 10 });
      testActor.removeKeyframeProperty('x', 0);

      equal(testActor.getPropertiesInTrack('x'), undefined, 'The property track was removed');
    });


    module('beforeRemoveKeyframeProperty event');


    test('beforeRemoveKeyframeProperty reflects the new state of the animation', function () {
      var rekapi = setupTestRekapi();
      var actor = setupTestActor(rekapi);

      actor.keyframe(0, { x: 0 }).keyframe(100, { x: 10 });
      var keyframeProperty = actor.getKeyframeProperty('x', 0);

      rekapi.on('beforeRemoveKeyframeProperty', function () {
        equal(rekapi.getAnimationLength(), 100, 'The timeline reflects the state before the removal of the keyframe');
      });

      actor.removeKeyframeProperty('x', 100);
    });


    module('removeKeyframePropertyComplete event');


    test('removeKeyframePropertyComplete reflects the new state of the animation', function () {
      var rekapi = setupTestRekapi();
      var actor = setupTestActor(rekapi);

      actor.keyframe(0, { x: 0 }).keyframe(100, { x: 10 });
      var keyframeProperty = actor.getKeyframeProperty('x', 0);

      rekapi.on('removeKeyframePropertyComplete', function () {
        equal(rekapi.getAnimationLength(), 0, 'The timeline reflects the removal of the keyframe');
      });

      actor.removeKeyframeProperty('x', 100);
    });


    module('getPropertiesInTrack');


    test('getPropertiesInTrack returns an array KeyframeProperties in a track',
        function () {

      var testRekapi
          ,testActor1;

      testRekapi = setupTestRekapi();
      testActor1 = setupTestActor(testRekapi);

      testActor1
        .keyframe(0, { x: 1 })
        .keyframe(1000, { x: 2 })
        .keyframe(2000, { x: 3 });

      equal(testActor1.getPropertiesInTrack('x').length, 3,
        'Returned the correct number of KeyframeProperties');
    });


    test('Actor track with no KeyframeProperties returns nothing', function () {
      var testRekapi
          ,testActor1;

      testRekapi = setupTestRekapi();
      testActor1 = setupTestActor(testRekapi);

      testActor1
        .keyframe(0, {})
        .keyframe(1000, {})
        .keyframe(2000, {});

      equal(testActor1.getPropertiesInTrack('x'), undefined,
          'No properties for track were found');
    });


    module('getStart');


    test('Get the start of an Actor\'s movement in the animation',
        function () {

      var testRekapi = setupTestRekapi();
      var testActor = setupTestActor(testRekapi);

      testActor
        .keyframe(250, {
          x: 1
        }).keyframe(1000, {
          x: 10
        }).keyframe(2000, {
          x: 20
        })

      equal(testActor.getStart(), 250,
          'Retrieved the correct time of the first keyframe');
    });


    test('Get the start of an Actor\'s property track',
        function () {

      var testRekapi = setupTestRekapi();
      var testActor = setupTestActor(testRekapi);

      testActor
        .keyframe(0, { y: 45 })
        .keyframe(250, { x: 1 })
        .keyframe(1000, { x: 10, y: 100 });

      equal(testActor.getStart('y'), 0,
          'Retrieved the correct time of the start of the "y" track');
      equal(testActor.getStart('x'), 250,
          'Retrieved the correct time of the start of the "x" track');
    });


    test('Get the start of an actor with no keyframes',
        function () {

      var testRekapi = setupTestRekapi();
      var testActor = setupTestActor(testRekapi);

      equal(testActor.getStart(), 0,
          'Retrieved the correct default start time');
    });


    module('getEnd');


    test('Get the end of an Actor\'s movement in the animation',
        function () {

      var testRekapi = setupTestRekapi();
      var testActor = setupTestActor(testRekapi);

      testActor
        .keyframe(250, {
          x: 1
        }).keyframe(1000, {
          x: 10
        }).keyframe(2000, {
          x: 20
        })

      equal(testActor.getEnd(), 2000,
          'Retrieved the correct time of the last keyframe');
    });


    test('Get the end of an Actor\'s property track',
        function () {

      var testRekapi = setupTestRekapi();
      var testActor = setupTestActor(testRekapi);

      testActor
        .keyframe(250,  { x: 1,  y: 10 })
        .keyframe(1000, { x: 10, y: 20 })
        .keyframe(2000, { x: 20 });

      equal(testActor.getEnd('x'), 2000,
          'Retrieved the correct time of the last keyframe for the "x" track');
      equal(testActor.getEnd('y'), 1000,
          'Retrieved the correct time of the last keyframe for the "y" track');
    });


    test('Out of order property tracks', function () {
      var testRekapi = setupTestRekapi();
      var testActor = setupTestActor(testRekapi);

      testActor
        .keyframe(0,    { x: 1  })
        .keyframe(2000, { x: 20 })
        .keyframe(1000, { x: 10 });

      testActor.modifyKeyframeProperty('x', 2000, { millisecond: 500 });

      equal(testActor.getEnd('x'), 1000);
    });


    module('getLength');


    test('Get the length of time that an Actor animates for', function () {

      var testRekapi = setupTestRekapi();
      var testActor = setupTestActor(testRekapi);

      testActor
        .keyframe(250, {
          x: 1
        }).keyframe(1000, {
          x: 10
        }).keyframe(2000, {
          x: 20
        })

      equal(testActor.getLength(), 1750,
          'Retrieved the correct length of time for an actor\s total movement');
    });


    test('Get the length of time that an Actor track animates for',
        function () {

      var testRekapi = setupTestRekapi();
      var testActor = setupTestActor(testRekapi);

      testActor
        .keyframe(0,    { y: 10 })
        .keyframe(250,  { x: 1  })
        .keyframe(1000, { x: 10 })
        .keyframe(2000, { y: 20 });

      equal(testActor.getLength('x'), 750,
          'Retrieved the correct length of time the "x" track');
      equal(testActor.getLength('y'), 2000,
          'Retrieved the correct length of time the "y" track');
    });


    module('getTrackNames');


    test('Actor track names can be retrieved', function () {
      var testRekapi
          ,testActor1;

      testRekapi = setupTestRekapi();
      testActor1 = setupTestActor(testRekapi);

      testActor1
        .keyframe(0, {
          a: 1
          ,b: 2
          ,c: 3
          ,d: 4
        });

      var trackNames = testActor1.getTrackNames();

      ok(_.contains(trackNames, 'a'), 'Track "a" exists');
      ok(_.contains(trackNames, 'b'), 'Track "b" exists');
      ok(_.contains(trackNames, 'c'), 'Track "c" exists');
      ok(_.contains(trackNames, 'd'), 'Track "d" exists');
      equal(trackNames.length, 4, 'There are only 4 track names');
    });


    module('exportTimeline');


    test('Exported Actor data has key data points', function () {
      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);
      testActor.keyframe(0, {
        'x': 1
        ,'y': 10
      }).keyframe(1000, {
        'x': 2
        ,'y': 20
      });

      var exportedActorData = testActor.exportTimeline();
      equal(exportedActorData.start, 0,
          'Actor start time is properly exported');
      equal(exportedActorData.end, 1000,
          'Actor end time is properly exported');
      ok(_.contains(exportedActorData.trackNames, 'x'),
          '"x"" track is in the trackName list');
      ok(_.contains(exportedActorData.trackNames, 'y'),
          '"y"" track is in the trackName list');
      equal(exportedActorData.trackNames.length, 2,
          'Only two track names were exported');
      equal(exportedActorData.propertyTracks.x.length, 2,
          'Data for all "x" KeyframeProperties was exported')
      equal(exportedActorData.propertyTracks.y.length, 2,
          'Data for all "y" KeyframeProperties was exported')
    });


    module('importTimeline');


    test('Imported data matches exported data', function () {
      var exportRekapi
          ,exportActor;

      exportRekapi = setupTestRekapi();
      exportActor = setupTestActor(exportRekapi);
      exportActor.keyframe(0, {
        'x': 1
        ,'y': 10
      }).keyframe(1000, {
        'x': 2
        ,'y': 20
      });

      var exportedActorData = exportActor.exportTimeline();
      var importActor = new Rekapi.Actor();
      importActor.importTimeline(exportedActorData);

      var firstImportXKeyProp = importActor.getKeyframeProperty('x', 0);
      var firstExportXKeyProp = exportActor.getKeyframeProperty('x', 0);
      equal(
          firstImportXKeyProp.value, firstExportXKeyProp.value,
          'First "X" keyframe value is the same in both actors');
      equal(
          firstImportXKeyProp.millisecond, firstExportXKeyProp.millisecond,
          'First "X" keyframe millisecond is the same in both actors');

      var secondImportXKeyProp = importActor.getKeyframeProperty('x', 1000);
      var secondExportXKeyProp = exportActor.getKeyframeProperty('x', 1000);
      equal(
          secondImportXKeyProp.value, secondExportXKeyProp.value,
          'First "X" keyframe value is the same in both actors');
      equal(
          secondImportXKeyProp.millisecond, secondExportXKeyProp.millisecond,
          'First "X" keyframe millisecond is the same in both actors');

      var firstImportYKeyProp = importActor.getKeyframeProperty('y', 0);
      var firstExportYKeyProp = exportActor.getKeyframeProperty('y', 0);
      equal(
          firstImportYKeyProp.value, firstExportYKeyProp.value,
          'First "Y" keyframe value is the same in both actors');
      equal(
          firstImportYKeyProp.millisecond, firstExportYKeyProp.millisecond,
          'First "Y" keyframe millisecond is the same in both actors');

      var secondImportYKeyProp = importActor.getKeyframeProperty('y', 1000);
      var secondExportYKeyProp = exportActor.getKeyframeProperty('y', 1000);
      equal(
          secondImportYKeyProp.value, secondExportYKeyProp.value,
          'First "Y" keyframe value is the same in both actors');
      equal(
          secondImportYKeyProp.millisecond, secondExportYKeyProp.millisecond,
          'First "Y" keyframe millisecond is the same in both actors');
    });


    module('data');


    test('Arbitrary data can be stored on an Actor', function () {

      var testRekapi = setupTestRekapi();
      var testActor = setupTestActor(testRekapi);

      testActor.data = { a: 'hello' };

      equal(testActor.data.a, 'hello',
          'Retrieved the data that was bound to the Actor');
    });


    module('Internals - KeyframeProperty tracks');


    test('Single keyframe properties are added to Actors successfully', function () {
      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);
      testActor.keyframe(0, {
        'x': 50
        ,'y': 50
      });

      var keyPropCount = 0;

      for (var keyProp in testActor._keyframeProperties) {
        keyPropCount++;
      }

      var propTrackCount = 0;

      for (var propTrack in testActor._propertyTracks) {
        propTrackCount++;
      }

      ok(testActor._keyframeProperties[keyProp] instanceof Rekapi.KeyframeProperty,
          'The Actor\'s _keyframeProperties Object contains KeyframeProperty instances')
      equal(testActor._propertyTracks.x.length, 1, 'Property was added to the "x" track');
      equal(testActor._propertyTracks.y.length, 1, 'Property was added to the "y" track');
      equal(keyPropCount, 2, 'The correct amount of KeyframeProperty instances were added');
      equal(propTrackCount, 2,
          'The correct amount of property tracks were added.');
    });


    test('Multiple keyframe properties are added to Actors successfully', function () {
      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);
      testActor.keyframe(0, {
          'x': 50
          ,'y': 50
        }).keyframe(1000, {
          'x': 100
          ,'y': 100
        });
      testActor._updateState(0);

      var keyPropCount = 0;

      for (var keyProp in testActor._keyframeProperties) {
        keyPropCount++;
      }

      equal(testActor._propertyTracks.x.length, 2,
          'Properties were added to the "x" track');
      equal(testActor._propertyTracks.y.length, 2,
          'Properties were added to the "y" track');
      equal(keyPropCount, 4,
          'The correct amount of KeyframeProperty instances were added');
      deepEqual(_.map(testActor._timelinePropertyCache, function (e) { return e._millisecond; }), [0, 1000],
          'The intenal _timelinePropertyCache timestamps are correct');
      equal(testActor._propertyTracks.x[0].nextProperty,
          testActor._propertyTracks.x[1],
          'The first tracked "x" KeyframeProperty instance\'s nextProperty is pointing to the correct property');
      equal(testActor._propertyTracks.y[0].nextProperty,
          testActor._propertyTracks.y[1],
          'The first tracked "y" KeyframeProperty instance\'s nextProperty is pointing to the correct property');
    });


    test('Can modify the position of a KeyframeProperty', function () {
      var testRekapi
          ,testActor;

      testRekapi = setupTestRekapi();
      testActor = setupTestActor(testRekapi);
      testActor.keyframe(0, {
          'x': 50
          ,'y': 50
        }).keyframe(1000, {
          'x': 100
          ,'y': 100
        });

      testActor.modifyKeyframeProperty('x', 1000, {
        'millisecond': 1500
      });

      testActor._updateState(0);

      var keyPropCount = 0;

      for (var keyProp in testActor._keyframeProperties) {
        keyPropCount++;
      }

      var propTrackCount = 0;

      for (var propTrack in testActor._propertyTracks) {
        propTrackCount++;
      }

      equal(keyPropCount, 4,
          'The number of KeyframeProperty instances on the Actor did not change');
      deepEqual(_.map(testActor._timelinePropertyCache, function (e) { return e._millisecond; }), [0, 1000, 1500],
          'The intenal _timelinePropertyCache timestamps are correct');
      equal(propTrackCount, 2,
          'The number of property tracks did not change');
      equal(testActor._propertyTracks.x.length, 2,
          'Modifying the property within it\'s track did not change the number of properties in the track');
      equal(testActor._timelinePropertyCache[0].x.millisecond, 0,
          'There is an "x" KeyframeProperty at 0');
      equal(testActor._timelinePropertyCache[0].y.millisecond, 0,
          'There is a "y" KeyframeProperty at 0');
      equal(testActor._timelinePropertyCache[1].x.millisecond, 0,
          'The "x" KeyframeProperty at 1000 milliseconds is pointing back to "x" property at 0 millisecond');
      equal(testActor._timelinePropertyCache[1].y.millisecond, 1000,
          'There is a "y" KeyframeProperty at 1000');
      equal(testActor._timelinePropertyCache[2].x.millisecond, 1500,
          'There is an "x" KeyframeProperty at 1500');
      equal(testActor._timelinePropertyCache[2].y,
          testActor._propertyTracks.y[1],
          'The second tracked "y" property is cached at the 1500 millisecond cache');
      equal(testActor._propertyTracks.x[0].nextProperty,
          testActor._propertyTracks.x[1],
          'The first tracked "x" KeyframeProperty instance\'s nextProperty did not change');
      equal(testActor._propertyTracks.y[0].nextProperty,
          testActor._propertyTracks.y[1],
          'The first tracked "y" KeyframeProperty instance\'s nextProperty did not change');
    });


    module('removeKeyframePropertyTrack event');


    test('removeKeyframePropertyTrack event is fired when a track is removed', function () {

      var rekapi = setupTestRekapi();
      var actor = setupTestActor(rekapi);

      actor.keyframe(0, { x: 10 });

      var eventWasCalled = false;
      var removedTrackName = '';

      rekapi.on('removeKeyframePropertyTrack', function (rekapi, trackName) {
        eventWasCalled = true;
        removedTrackName = trackName;
      });

      actor.removeKeyframe(0);
      ok(eventWasCalled, 'removeKeyframePropertyTrack event was called');
      equal(removedTrackName, 'x', 'The name of the removed track name was provided to the event handler.');
    });


    module('Multiple Actors');


    test('Early-ending Actors reach their final state', function () {

      var testRekapi = setupTestRekapi();
      var testActor1 = setupTestActor(testRekapi);
      var testActor2 = setupTestActor(testRekapi);

      testActor1.keyframe(0, {
          'x': 0
        }).keyframe(1000, {
          'x': 100
        });

      testActor2.keyframe(0, {
          'x': 0
        }).keyframe(500, {
          'x': 100
        });

      testRekapi._loopTimestamp = 0;
      mockTime = function () { return 250; };
      Rekapi._private.updateToCurrentMillisecond(testRekapi);

      equal(testActor1.get().x, 25,
          'testActor1 has correct midpoint while both Actors are animating');
      equal(testActor2.get().x, 50,
          'testActor2 has correct midpoint while both Actors are animating');

      mockTime = function () { return 750; };
      Rekapi._private.updateToCurrentMillisecond(testRekapi);

      equal(testActor1.get().x, 75,
          'testActor1 has correct midpoint while still animating after testActor2 has finished');
      equal(testActor2.get().x, 100,
          'testActor2 has correct ending position after finishing before testActor1');

    });


    module('Function keyframes');


    test('A lone function keyframe on the timeline gets called', function () {
      var rekapi = new Rekapi();
      var actor = rekapi.addActor();

      var functionWasCalled = false;
      actor.keyframe(0, function () {
        functionWasCalled = true;
      });

      rekapi._loopTimestamp = 0;
      mockTime = function () { return 0; };
      Rekapi._private.updateToCurrentMillisecond(rekapi);

      ok(functionWasCalled, 'The function at keyframe 10 was called.');
    });

    test('A function keyframe on the timeline with other properties gets called', function () {
      var rekapi = new Rekapi();
      var actor = rekapi.addActor();

      var functionWasCalled = false;
      actor.keyframe(10, function () {
        functionWasCalled = true;
      });

      actor.keyframe(20, { x: 1 });

      rekapi._loopTimestamp = 0;
      mockTime = function () { return 5; };
      Rekapi._private.updateToCurrentMillisecond(rekapi);
      ok(!functionWasCalled, 'The function at keyframe 10 was not yet called.');

      // Note: 20 causes the loop to start over and be evaluated as 0 in
      // KeyframeProperty#shouldInvokeForMillisecond.
      mockTime = function () { return 19; };
      Rekapi._private.updateToCurrentMillisecond(rekapi);

      ok(functionWasCalled, 'The function at keyframe 10 was called.');
    });

    test('Function keyframe callbacks receive drift value and context', function () {
      var rekapi = new Rekapi();
      var actor = rekapi.addActor();

      var receivedDrift = null;
      var context;
      actor.keyframe(0, function (drift) {
        context = this;
        receivedDrift = drift;
      });

      actor.keyframe(20, { x: 1 });

      rekapi._loopTimestamp = 0;
      mockTime = function () { return 5; };
      Rekapi._private.updateToCurrentMillisecond(rekapi);

      equal(receivedDrift, 5, 'drift was passed along');
      equal(context, actor, 'Callback was called in the context of the actor');
    });

    test('A function keyframe only gets called once per loop iteration', function () {
      var rekapi = new Rekapi();
      var actor = rekapi.addActor();

      var functionCalls = 0;
      actor.keyframe(10, function () {
        functionCalls += 1;
      });

      actor.keyframe(20, { x: 1 });

      rekapi._loopTimestamp = 0;
      mockTime = function () { return 12; };
      Rekapi._private.updateToCurrentMillisecond(rekapi);
      mockTime = function () { return 13; };
      Rekapi._private.updateToCurrentMillisecond(rekapi);
      equal(functionCalls, 1, 'The function was called once');

      // Reset the loop
      mockTime = function () { return 21; };
      Rekapi._private.updateToCurrentMillisecond(rekapi);
      mockTime = function () { return 12; };
      Rekapi._private.updateToCurrentMillisecond(rekapi);
      equal(functionCalls, 2, 'The loop was reset and the function was called again');
    });

    test('A function keyframe doesn\'t require non-function keyframes in the timeline to be invoked', function () {
      var rekapi = new Rekapi();
      var actor = rekapi.addActor();

      var calledFn1 = false;
      actor.keyframe(10, function () {
        calledFn1 = true;
      });

      var calledFn2 = false;
      actor.keyframe(20, function () {
        calledFn2 = true;
      });

      rekapi._loopTimestamp = 0;
      mockTime = function () { return 5; };
      Rekapi._private.updateToCurrentMillisecond(rekapi);
      ok(!calledFn1, 'The first function was not called');
      ok(!calledFn2, 'The second function was not called');

      mockTime = function () { return 15; };
      Rekapi._private.updateToCurrentMillisecond(rekapi);
      ok(calledFn1, 'The first function was called');
      ok(!calledFn2, 'The second function was not called');

      mockTime = function () { return 20; };
      Rekapi._private.updateToCurrentMillisecond(rekapi);
      ok(calledFn1, 'The first function was called');
      ok(calledFn2, 'The second function was called');
    });

    test('A lone function keyframe at millisecond 0 is called with each loop iteration', function () {
      var rekapi = new Rekapi();
      var actor = rekapi.addActor();

      var callCount = 0;
      actor.keyframe(0, function () {
        callCount++;
      });

      rekapi._loopTimestamp = 0;
      mockTime = function () { return 0; };
      Rekapi._private.updateToCurrentMillisecond(rekapi);
      equal(callCount, 1, 'The function was called for the first iteration');

      mockTime = function () { return 1; };
      Rekapi._private.updateToCurrentMillisecond(rekapi);
      equal(callCount, 2, 'The function was called for the second iteration');
    });

    test('A function keyframe at the end of the loop only gets called once', function () {
      var rekapi = new Rekapi();
      var actor = rekapi.addActor();

      var callCount = 0;
      actor
        .keyframe(10, {
          'function': function () {
            callCount++;
          }
        });

      rekapi._timesToIterate = 1;
      Rekapi._private.updateToMillisecond(rekapi, 10);
      equal(callCount, 1, 'The function was only called once');
    });

    module('_resetFnKeyframesFromMillisecond');


    test('_resetFnKeyframesFromMillisecond resets function keyframes later but not before specified millisecond', function () {
      var rekapi = new Rekapi();
      var actor = rekapi.addActor();

      var callCount = 0;
      actor
        .keyframe(10, {
          'function': function () {
            callCount++;
          }
        })
        .keyframe(20, {
          'function': function () {
            callCount++;
          }
        });

      rekapi._timesToIterate = 1;

      Rekapi._private.updateToMillisecond(rekapi, 5);
      equal(callCount, 0, 'The function was not called');

      Rekapi._private.updateToMillisecond(rekapi, 15);
      equal(callCount, 1, 'The function was called once');

      actor._resetFnKeyframesFromMillisecond(2);
      Rekapi._private.updateToMillisecond(rekapi, 15);
      equal(callCount, 2, 'The function was called twice');

      Rekapi._private.updateToMillisecond(rekapi, 15);
      equal(callCount, 2, 'Further calls to updateToCurrentMillisecond do not fire function keyframes');
    });

  } ());
  </script>
</head>
<body>
  <h1 id="qunit-header"><a href="https://github.com/jeremyckahn/rekapi">rekapi</a></h1>
   <h2 id="qunit-banner"></h2>
   <div id="qunit-testrunner-toolbar"></div>
   <h2 id="qunit-useragent"></h2>
   <ol id="qunit-tests"></ol>
   <div id="qunit-fixture"></div>
</body>
</html>
